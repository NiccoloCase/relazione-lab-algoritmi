\documentclass{article}


\usepackage[italian]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{lipsum}
\usepackage{fancyhdr}
\usepackage{titlesec}
\usepackage{tocloft}
\usepackage{titling}
\usepackage{geometry}
\usepackage{float} % Per utilizzare l'opzione H nelle immagini
\usepackage{caption}
\usepackage{multicol} % molteplici colonne
\usepackage{todonotes}  % note

\usepackage{csvsimple} 

% Formattare codice
\usepackage{listings}
\lstset{language=Python}
\renewcommand{\lstlistingname}{Codice}

% Citazioni 
\usepackage{csquotes}
\usepackage[backend=biber, style=verbose]{biblatex}
\addbibresource{cit.bib}

% Riferimenti
\usepackage[noabbrev]{cleveref}
\crefname{figure}{Figura}{Figure}
\Crefname{figure}{Figura}{Figure}



% Configurazione label immagini
\DeclareCaptionLabelFormat{myformat}{#1~#2}
\captionsetup[figure]{labelformat=myformat}


% Box citazioni
\usepackage{tcolorbox}
\newtcolorbox[auto counter,number within=section]{mybox}[1][]{
    colback=white,
    colframe=black,
    sharp corners, 
    width=0.8\linewidth, 
    center title, 
    title={\textbf{Proprietà (\thetcbcounter)}},
    #1
}


% Margini
\geometry{a4paper, margin=2cm}

% Titolo
\title{Alberi Binari di Ricerca con Chiavi Duplicate}
\author{Niccolò Caselli}
\date{20/01/2024}
\renewcommand{\maketitlehooka}{\centering\includegraphics[width=0.5\textwidth]{logo}\vspace{1cm}}
\renewcommand{\maketitlehookb}{\centering\LARGE}
\renewcommand{\maketitlehookc}{\vspace{1cm}\centering\Large}

% Indice
\renewcommand{\cftsecleader}{\cftdotfill{\cftdotsep}}
\setlength{\cftbeforesecskip}{8pt}

% Configurazione degli stili di pagina
\pagestyle{fancy}
\fancyhf{}
\rhead{\thepage}
\lhead{\nouppercase{\leftmark}}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}

% Configurazione dei titoli delle sezioni
\titleformat{\section}[block]{\normalfont\Large\bfseries}{\thesection}{1em}{}
\titlespacing*{\section}{0pt}{\baselineskip}{\baselineskip}




\begin{document}

% PAGINA INIZIALE
\begin{titlepage}
  \maketitle
  \vspace*{\fill}
  \begin{center}
    \textbf{Relazione di Laboratorio di Algoritmi e Strutture Dati}
  \end{center}
  \vspace*{\fill}
\end{titlepage}


% INDICE
\renewcommand{\contentsname}{Indice} % Titolo dell'indice
\tableofcontents
\newpage

\section{Introduzione}
\lipsum[1]


\section{Cenni sugli Alberi Binari di Ricerca}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.7\textwidth]{./images/bst-generic}
  \caption{Esempio di albero binario di ricerca}
  \label{fig:bst-generic}
\end{figure}


\subsection{Cos'è un albero binario di Ricerca?}
\label{subsec:bst-introduction}
Prima di esaminare il problema delle chiavi duplicate cerchiamo di capire cos'è un albero binario di ricerca (abbreviato spesso in B.S.T dall'inglese).
Un BST è un tipo di struttura dati basata su gli alberi, definiti nel libro  \emph{\citefield{cormen2023}{title}} come "grafi non orientati, connessi e aciclici".
Tale struttura ha la caratteristica di permettere le operazioni di base in O(h), con h l'altezza dell'albero, che gli rende efficienti per la realizzazione di dizionari, ricerca di valori, e attraversamenti. \\
Un albero binario di ricerca è costituito da una serie di nodi che nel calcolatore possono essere rappresentati con oggetti con i seguenti attributi:

\begin{itemize}
    \item una chiave (x.key)
    \item un puntatore al figlio sinistro (x.left)
    \item un puntatore al figlio destro (x.right)
    \item un puntatore al padre (x.p)
\end{itemize}

Enunciamo quindi la proprietà fondamentale di un albero binario di ricerca:

\begin{center}
\begin{mybox}
	\begin{itemize}
    \item Se y è nel sottoalbero sinistro di x, allora \(y.key < x.key\) 
     \item Se y è nel sottoalbero destro di x, allora \(y.key > x.key\) 
	\end{itemize}
\end{mybox}
\end{center}
\label{prop:bst-prop} 

Tale caratteristica dei BST è facilmente individuabile nell'albero di esempio di \cref{fig:bst-generic}. 




\subsection{Implementazione in Python}

Come già accennato possiamo rappresentare un albero binario con l'ausilio delle classi. Creiamo quindi una classe per rappresentare l'intero albero e una classe per il singolo nodo dell'albero. Tra queste due classi vi è quindi un relazione 
\textit{one-to-many}.

\vspace{5pt}

\begin{lstlisting}[language=Python, caption={Implementazione di un BST}, label=bst-implementation]


class Node:
    def __init__(self, key):
        self.key = key
        self.left = None
        self.right = None

class BST:
    def __init__(self):
        self.root = None

    # Imposta la radice dell'albero
    def setRoot(self, key):
        self.root = Node(key)

    # Inserisce un nodo nell'albero
    def insert(self, key):
        if (self.root is None):
            self.setRoot(key)
        else:
            self._insertNode(self.root, key)

    # Funzione di supporto per l'inserimento di un nodo
    def _insertNode(self, currentNode, key):
        if (key < currentNode.key):
            if (currentNode.left):
                self._insertNode(currentNode.left, key)
            else:
                currentNode.left = Node(key)
        elif (key > currentNode.key):
            if (currentNode.right):
                self._insertNode(currentNode.right, key)
            else:
                currentNode.right = Node(key)
\end{lstlisting}

\vspace{5pt}

Per ovvi motivi di impaginazione è stato riportato solo parte del codice; il lettore può quindi estenderlo a suo piacere implementando i metodi per gli attraversamenti dell'albero e la ricerca.
Come già sottolineato (Vedi \ref{subsec:bst-introduction}) il vantaggio di questa struttura dati è il costo asintotico delle sue operazioni di base. Più nello specifico, è evidente dalla funzione precedentemente mostrata, l'inserimento in un albero binario è un operazione che richiede $O(h)$ (dal momento che prima di inserire un nuovo nodo bisogna raggiungere una foglia percorrendo al più tutta l'altezza dell'albero - h). Lo stesso discorso si applica per la ricerca e cancellazione (risulta invece diverso il caso degli attraversamenti - in ordine, posticipato e anticipato - che richiedono $\Theta(n)$).
Questo aspetto è fondamentale poiché spiega l'esigenza, su cui torneremo, di avere alberi il più possibili bilanciati. \\
È infine degna di nota la funzione ricorsiva usata nella relazione per la rappresentazione grafica dei BST.

\begin{lstlisting}[language=Python, caption={Rappresentazione Grfaica di un BST}, label={lst:plot_tree}]
def plot_tree(tree):
    fig, ax = plt.subplots()
    _plot_tree(ax, tree.root, x=0, y=0, level=1)
    ax.axis('off')
    plt.show()

def _plot_tree(ax, node, x, y, level):
    if node is not None:
        ax.annotate(node.key, (x, y), xytext=(x, y),
                color="white",    
                ha='center',
                va='center', 
                bbox=dict(boxstyle='circle', fc='#505050')
        )

    xfactor = 1/2
    y_new = level * -2

    if node.left is not None:
        x_new = x - xfactor ** level
        ax.plot([x, x_new], [y, y_new], linewidth=.8,color="#404040")
        _plot_tree(ax, node.left, x_new, y_new, level + 1)

    if node.right is not None:
        x_new = x + xfactor ** level
        ax.plot([x, x_new], [y, y_new],  linewidth=.8, color="#404040")
        _plot_tree(ax, node.right, x_new, y_new, level + 1)
\end{lstlisting}


\section{Il Problema delle Chiavi Duplicate}
La definizione data fin'ora di Albero Binario di Ricerca si basa sulla fondamentale supposizione di unicità delle chiavi
(come implicito nella proprietà \ref{prop:bst-prop}).
Sappiamo però che questa ipotesi è difficilmente riscontrabile nelle applicazioni reali:
entriamo, dunque, nel merito del problema delle chiavi duplicate.

Possiamo trovare vari possibili approcci per gestire il problema, in questa relazione ne verranno discussi tre:  



\begin{itemize}
	\item Implementazione \textit{normale} (\ref{subsec:normal-implementation}).
	\item Implementazione con Flag Booleano (\ref{subsec:fag-implementation}).
	\item Implementazione con Lista Concatenata (\ref{subsec:list-implementation}).
\end{itemize}




\subsection{Premessa sulla ricerca}\label{subsec:search-int}Nonostante i test eseguiti e la relazione si concentreranno  sull'inserimento, è comunque necessario fare una premessa su cosa intendiamo come ricerca in un Albero Binario di Ricerca con chiavi duplicate. A seconda del tipo di utilizzo che vogliamo dare a un BST possiamo infatti realizzare diversamente la ricerca. In alcuni testi la ricerca di un nodo è descritta come un metodo che restituisce semplicemente se è presente o meno una specifica chiave in un albero o, in alternativa, che restituisce il primo nodo con tale chiave. In questi due specifici casi non bisogna mettere in pratica nessuna modifica nella implementazione precedente, tuttavia ciò è molto limitante: sebbene per motivi didattici quando si tratta i BST si tende a semplificare considerando ogni nodo solo dalla sua chiave, nella realtà, ogni nodo contiene anche dati satelliti. Ne consegue che sebbene due nodi possano avere una stessa chiave, il loro valore può essere diverso.
È il caso ad esempio dei dizionari; se in Javascript e Python non sono supportate le chiavi duplicate nei dizionari (oggetti in Javascript), un esempio valido sono invece le \textit{multimap} del c++ le quali, data una chiave, restituiscono tutti i valori associati a tale chiave. Questo è l'approccio seguito in questa relazione. 
 

 
\subsection{Implementazione "normale"}\label{subsec:normal-implementation}
Un primo possibile approccio alla questione delle chiavi duplicate, e senza dubbi quello più immediato, è semplicemente aggiustare la definizione, volutamente ambigua, fornita precedentemente (vedi proprietà \ref{prop:bst-prop}).\\
Possiamo quindi riformulare la relazione tra i nodi di un BST affinché supporti l'inserimento quando la chiave da inserire è già presente nell'albero:

\begin{center}
\begin{mybox}
	\begin{itemize}
    \item Se y è nel sottoalbero sinistro di x, allora \(y.key \le x.key\) 
     \item Se y è nel sottoalbero destro di x, allora \(y.key > x.key\) 
	\end{itemize}
\end{mybox}
\end{center}
\label{prop:bst-normal-implementation-prop}

Questa modifica comporta quindi un cambiamento dell'implementazione dell'inserimento nella classe BST: al momento dell'inserimento i nodi con stessa chiave vengono inseriti come figli sinistri del primo nodo con tale chiave (e così via ricorsivamente). Aggiustiamo quindi il codice.

\begin{lstlisting}[language=Python, caption={Funzione ausiliaria di inserimento aggiornata}]
    def _insertNode(self, currentNode, key):
        if (key <= currentNode.key):
            if (currentNode.left):
                self._insertNode(currentNode.left, key)
            else:
                currentNode.left = Node(key)
        elif (key > currentNode.key):
            if (currentNode.right):
                self._insertNode(currentNode.right, key)
            else:
                currentNode.right = Node(key)
\end{lstlisting}

\begin{figure}[htbp]
  \begin{minipage}{0.5\textwidth}
    \centering
    \includegraphics[width=\linewidth]{./images/bst-normal-img1}
    \caption{BST con chiavi duplicate}
    \label{fig:bst-normal-img1}
  \end{minipage}%
  \begin{minipage}{0.5\textwidth}
    \centering
    \includegraphics[width=\linewidth]{./images/bst-normal-img2}
    \caption{Altro esempio di BST con chiavi duplicate}
    \label{fig:bst-normal-img2}
  \end{minipage}
\end{figure}



Nella \cref{fig:bst-normal-img1} possiamo vedere l'albero derivante dall'inserimento ordinato dei seguenti elementi \(\mathbf{\{3, 1, 2, 2, 2, 4\}}\). Notiamo quindi che vi sono tre nodi con la stessa chiave 2, ognuno dei quali è nel sotto-albero sinistro del nodo padre più vicino con la medesima chiave.
\\
Non bisogna però cadere nella convinzione che nodi con stessa chiave si trovino sempre tutti adiacenti l'uno con l'altro.
A questo scopo si consideri la \cref{fig:bst-normal-img2}:  cambiando semplicemente l'ordine di inserimento dei valori della figura precedente (ora \(\mathbf{\{3, 2, 2, 1, 2, 4\}}\)) il risultato è molto diverso; tra il penultimo e l'ultimo nodo con chiave 2 vi è in mezzo un nodo con chiave 1!
Questo può portare a complicazioni nella ricerca, che verrà affrontata in seguito. \\

Il principale svantaggio di questa implementazione è che l'inserimento di tante chiavi uguali può tendere a sbilanciare l'albero il quale finisce per degenerare in una semplice lista. Infatti, è evidente che per creare l'albero di N elementi più sbilanciato possibile sia sufficiente inserire N volte la stessa chiave. Come in esempio (\cref{fig:bst-normal-img3}).


\begin{figure}[H]
  \centering
  \includegraphics[width=0.7\textwidth]{./images/bst-normal-img3}
  \caption{Esempio di albero binario di ricerca sbilanciato}
  \label{fig:bst-normal-img3}
\end{figure}



\subsection{Metodo del Falg Booleano}
\label{subsec:fag-implementation}

Un altro possibile approccio al caso delle chiavi duplicate è, invece di inserire sempre i nodi con chiave duplicate a sinistra del nodo padre, inserire i nodi con chiave duplicate a sinistra o destra del padre a seconda di un flag booleano. Più nello specifico: estendiamo la struttura dati di ogni nodo dell'albero così che il generico nodo x abbia un nuovo attributo \textit{x.flag} e quindi, durante l'inserimento, porre x a \textit{x.left} o \textit{x.right} a seconda del valore del flag, il quale viene alternato a ogni visita di x con chiave uguale. 

Il punto di forza di questa implementazione è il fatto che tende a preservare il bilanciamento dell'albero anche in presenza di molte chiavi duplicate, a differenza del primo approccio (Vedi \ref{subsec:normal-implementation}). Ciò risulta evidente se si prova a disegnare l'albero risultante dall'inserimento di N chiavi uguali (Vedi \cref{fig:bst-flag}).



\begin{figure}[H]
  \centering
  \includegraphics[width=0.7\textwidth]{./images/bst-flag}
  \caption{BST con Flag Booleano di 64 chiavi uguali}
  \label{fig:bst-flag}
\end{figure}



Per quanto riguarda il codice, le modifiche da apportare sono minime.
Aggiungiamo il nuovo attributo nella classe Nodo:

\begin{lstlisting}[language=Python, caption={Classe nodo di un BST con Flag Booleano}]
class Node:
    def __init__(self, key):
        self.key = key
        self.left = None
        self.right = None
        self.flag = False # <---
\end{lstlisting}

E aggiorniamo la funzione di supporto per l'inserimento:

\begin{lstlisting}[language=Python]
    def _insertNode(self, currentNode, key):        
        if(currentNode.key == key):
            if(currentNode.flag): self._insert_right(currentNode, key)
            else: self._insert_left(currentNode, key)
            currentNode.flag = not currentNode.flag # Alterna il flag
    
        if (key < currentNode.key): self._insert_left (currentNode, key)
        elif (key > currentNode.key): self._insert_right(currentNode, key)

    # Funzione di supporto per l'inserimento di un nodo a sinistra
    def _insert_left(self, currentNode, key):
        if (currentNode.left): self._insertNode(currentNode.left, key)
        else: currentNode.left = Node(key)

    # Funzione di supporto per l'inserimento di un nodo a destra
    def _insert_right(self, currentNode, key):
        if (currentNode.right): self._insertNode(currentNode.right, key)
        else: currentNode.right = Node(key)
\end{lstlisting}











\subsection{Metodo della Lista Concatenata}
\label{subsec:list-implementation}

\begin{figure}[htbp]
  \begin{minipage}{0.48\textwidth}  % Riduci la larghezza della prima minipage
    \centering
    \includegraphics[width=\linewidth]{./images/bst-list-img1}
    \caption{BST con gestione chiavi duplicate tramite lista concatenata}
    \label{fig:bst-list-img1}
  \end{minipage}%
  \hfill  % Aggiungi uno spazio orizzontale tra le due colonne
  \begin{minipage}{0.48\textwidth}  % Riduci la larghezza della seconda minipage
    \centering
    \includegraphics[width=\linewidth]{./images/bst-list-img2}
    \caption{BST con lista concatenata di 100 chiavi uguali}
    \label{fig:bst-list-img2}
  \end{minipage}
\end{figure}



L'ultimo approccio possibile trattato in questa relazione è quello  della lista concatenata: inseriamo tutti i nodi con chiave uguale in una lista concatenata.
Una possibile implementazione nel codice è di estendere la classe Nodo con un puntatore \textit{next} al prossimo elemento della lista concatenata. Nel mio caso ho aggiunto anche un capo   \textit{duplicates} che, nel primo nodo, tiene il conteggio dei nodi con chiave duplicata per esigenze rappresentative.

\begin{lstlisting}[language=Python, caption={Classe Nodo di un BST con lista concatenata}]
class Node:
    def __init__(self, key):
        self.key = key
        self.left = None
        self.right = None
        self.next = None # <---
        self.duplicates = 0 # <---
\end{lstlisting}

A questo punto, in fase di inserimento, se si trova un nodo con stessa chiave già esistente basta inserire il nuovo nodo.

\begin{lstlisting}[language=Python, caption={Gestione chiavi duplicate con lista concatenata}]
     if (key == currentNode.key):
            newNode = Node(key)
            newNode.next = currentNode.next
            currentNode.next = newNode
            currentNode.duplicates += 1

\end{lstlisting}

\vspace{20px}

Apportando una semplice modifica alla funzione \textit{plot\_tree} (Vedi codice~\ref{lst:plot_tree}) possiamo visualizzare questo approccio in Figura \ref{fig:bst-list-img1} e Figura \ref{fig:bst-list-img2}.
Per ogni nodo è segnato tra parentesi il numero di occorrenze di quella chiave.



\section{Test delle prestazioni}
Entriamo ora nel dettaglio sulle prestazioni di queste tre possibili implementazioni.
Esaminiamo quindi il problema dell'inserimento di n chiavi identiche all'interno di un BST inizialmente vuoto e l'operazione di ricerca. 

\subsection{Analisi Teorica}

Come già discusso nel paragrafo \ref{subsec:normal-implementation} l'implementazione senza particolari accorgimenti ha il problema della degenerazione dell'albero in una lista del caso di un elevato numero di inserimento con stessa chiave.
La teoria ci dice infatti che l'inserimento in un albero di ricerca è un operazione che richiede $O(h)$; tuttavia, come immaginabile dalla \cref{fig:bst-normal-img3}, nell'inserimento di n chiavi identiche si deve ogni volta arrivare in fondo all'albero di altezza $h=n$. Ne consegue che ci si aspetta un comportamento lineare $\Theta(n)$.
\\
Il secondo approccio (Paragrafo \ref{subsec:fag-implementation}) evita questa problematica e cerca di preservare il bilanciamento dell'albero. L'altezza diventa quindi funzione logaritmica e la complessità  per l'inserimento $\Theta(log(n))$.
\\
Infine per quanto riguarda l'inserimento con l'approccio tramite lista concatenata (Vedi \ref{subsec:list-implementation}) sappiamo che una volta trovato il primo nodo con chiave uguale, l'inserimento in testa alla lista concatenata è un'operazione $\Theta(1)$; dobbiamo però prima trovare tale nodo, il quale può anche non esistere. Abbiamo allora $O(h) + \Theta(1) = O(h)$. 
Tuttavia, nel caso del test di inserimento di n chiavi uguali l'albero degenera in un singolo nodo (Vedi Figura \ref{fig:bst-list-img2}) e quindi la complessità risultante diventa $\Theta(1) + \Theta(1) = \Theta(1)$.


\subsection{Risultati Sperimentali}

Come già detto il test eseguito consiste nell'inserire N (numero molto grande) volte la stessa medesima chiave in un albero binario di ricerca per comprendere in questo \underline{caso estremo} le differenze tra le tre implementazioni.

Il primo approccio, come si ipotizzato nel paragrafo precedente, si è rilevato il più dispendioso di risorse computazionali e di tempo. Infatti, se ii grafici generarti per gli altri due casi arrivano fino all'inserimento in Alberi Binari di Ricerca di fino \underline{un milione} di elementi, nel caso dell'implementazione classica del BST il test è stato eseguito fino a un albero di \underline{200-mila elementi}. Come apprezzabile dal grafico riportato, il costo di questa operazione segue un andamento lineare e già i vari test fino a 200.000 chiavi hanno impiegato sul mio calcolatori (Vedi la nota sui test) più di mezz'ora di esecuzione. I test su N nell'ordine dei milioni, che ho più volte tentato, era semplificante non praticabile, e a mio avviso nemmeno significativo. Per i test è stata inoltre apportata una modifica alla classe Albero per tenere traccia del numero di iterazioni (in realtà se si vuole essere precisi, ricorsioni) che sono state necessarie per l'inserimento di ogni valore in un albero di dimensione n. Ad ogni dimensione dell'albero, quindi, sono stati salvati i tempi di esecuzione e il numero di iterazioni impiegati in un dizionario, ovvero un hash table di Python, utilizzando il valore corrente di n come chiave.
A conferma dell'andamento lineare dell'inserimento con il primo approccio è quindi anche il grafico del numero di interazioni e, sopratutto, la tabella (\ref{tab:bst-insertion-summarised}) che ci mostra chiaramente l'identità tra il numero di elementi dell'albero e il numero di interazioni necessarie per l'inserimento (questo ovviamente perché necessario scorrere tutto l'albero degenerato in una lista concatenata).


\begin{figure}[htbp]
 \begin{minipage}{0.5\textwidth}
    \centering
    \includegraphics[width=\linewidth]{./tests_output/bst/insertion.png}
    \caption{Prestazioni di inserimento di 200.000 chiavi identiche un BST senza accorgimenti particolari}
    \label{fig:bst-normal-insetion}
  \end{minipage}
    \hspace{0.05\textwidth}
  \begin{minipage}{0.5\textwidth}
    \centering
    \includegraphics[width=\linewidth]{./tests_output/bst/insertion_iterations.png}
    \caption{Variazione del numero di iterazioni per l'inserimento in un BST di 200.000 chiavi identiche}
    \label{fig:bst-normal-insetion-iterations}
  \end{minipage}%
\end{figure}



\begin{minipage}[t]{\linewidth}
\begin{multicols}{2}
\begin{minipage}{\linewidth}
    \centering
    \csvautotabular{./tests_output/bst/insertion_summarised.cvs} % Percorso corretto per la prima tabella
    \captionof{table}{Risultati dell'inserimento in un BST normale}
    \label{tab:bst-insertion-summarised}
\end{minipage}
\columnbreak
\begin{minipage}{\linewidth}
    \centering
    \csvautotabular{./tests_output/bst/insertion_iterations_summarised.cvs} % Percorso corretto per la seconda tabella
    \captionof{table}{Numero di iterazioni nell'inserimento in un BST normale}
    \label{tab:bst-insertion-summarised}
\end{minipage}
\end{multicols}
\end{minipage}
\vspace{15px}



    \todo[inline, size=\small, backgroundcolor=gray!20, linecolor=gray, caption={\textit{}}]{\textbf{Nota sulle tabelle}. I test sono stati eseguiti su alberi di dimensioni fino a un milione di elementi e sono stati salatavi i risultati in file \textit{.xlsx} da migliaia di righe. Ne consegue che, per ovvi motivi, questi file sono stati successivamente abbreviati selezionando solo le misurazioni più significative da un altro script Python.}

\vspace{15px}

L'approccio del Flag Booleano da un punto di vista teorico dovrebbe dimostrarsi caratterizzato da una complessità logaritmica, tuttavia in questo caso diventa già molto più difficile interpretare il grafico.
Infatti, quando si parla di logaritmo spesso si tende a sottostimare quando questa funzione cresci lentamente: nel caso di   10.000 elementi sono necessarie solo 13 iterazioni per arrivare in fondo all'albero e inserire un nuovo valore; con un milione di elementi si sale ad appena a 19 iterazioni. Risulta evidente che per un calcolatore moderno la differenza, ad esempio, tra 13 o 19 iterazioni (e quindi di fatto confronti) è praticamente impercettibile e quindi il grafico risulta quasi costante e indistinguibile con quello del \textit{BST LIST}.
I test sono stati eseguiti su 1 milione di elementi e hanno impiegato un tempo quasi insignificante. Tuttavia, cercando di aumentare il numero di elementi ho riscontrato dei problemi con il terminale e l'editor di testo che sono andati in crash. Suppongo però, mettendo le mani aventi poiché non ne posso avere la certezza, che questo sia un problema specifico dell'IDE, o della gestione del sistema o di Python delle chiamate ricorsive.

Nonostante tutto ciò, dopo aver messo in atto accorgimenti alla visualizzazione del grafico e zoomando nella sezione di interesse, è possibile scorgere l'andamento logaritmico, anche se con molto rumore (dovuto probabilmente ad altri processi del calcolatore e in generale all'aleatorietà di tale tipo di test quando si va a considerare intervalli di tempo così ridotti).
Questo risulta ancora pià evidente se si prende in considerazione il grafico delle iterazioni di inserimento.

\begin{figure}[htbp]
 \begin{minipage}{0.5\textwidth}
    \centering
    \includegraphics[width=\linewidth]{./tests_output/bst_flag/insertion.png}
    \caption{Prestazioni di inserimento di 1.000.000 chiavi identiche un BST con Flag booleano}
    \label{fig:bst-flag-insetion}
  \end{minipage}
      \hspace{0.05\textwidth}
  \begin{minipage}{0.5\textwidth}
    \centering
    \includegraphics[width=\linewidth]{./tests_output/bst_flag/insertion_iterations.png}
    \caption{Iterazioni nell'inserimento di 1.000.000 chiavi identiche un BST con Flag booleano}
    \label{fig:bst-flag-insetion-iterations}
  \end{minipage}%
\end{figure}

\vspace{10px}
L'approccio della Lista Concatenata deve avere come grafico un andamento costante, e così è. Nuovamente, risulta tuttavia di non immediata interpretazione: infatti, se rappresentiamo il grafico concentrandosi sulla zona d interesse, come nel caso di \cref{fig:bst-list-insetion}, essendo che in questo caso l'operazione di inserimento è molto veloce e poco dispendiosa di risorse, si ha che la variabile di incertezza/casualità influenza maggiormente il risultato.
Ecco perché il grafico in \cref{fig:bst-list-insetion} non risulta perfettamente come costante, ma i valori dei test si distribuiscono quasi uniformemente tra un range di valori. È inoltre fondamentale notare come la scala verticale dei grafici di   \cref{fig:bst-list-insetion} e  \cref{fig:bst-flag-insetion} sia dversa; rispettivamente dell'ordine di 10e-6 per la prima e 10e-7 per la seconda, che quindi risulta più "zoomata". Analizzando le Tabelle \ref{tab:bst-flag-insertion-summarised} e \ref{tab:bst-list-insertion-summarised} emerge subito come l'ultimo approccio abbia prestazioni effettivamente quasi costanti e, sopratutto, di un ordine di grandezza 10 volte più piccolo dell'implementazione con Flag Booleano.


\begin{figure}[htbp]
 \begin{minipage}{0.5\textwidth}
    \centering
    \includegraphics[width=\linewidth]{./tests_output/bst_list/insertion.png}
    \caption{Prestazioni di inserimento di 1.000.000 chiavi identiche un BST con Lista Concatenata}
    \label{fig:bst-list-insetion}
  \end{minipage}
      \hspace{0.05\textwidth}
  \begin{minipage}{0.5\textwidth}
    \centering
    \includegraphics[width=\linewidth]{./tests_output/bst_list/insertion_iterations.png}
    \caption{Iterazioni nell'inserimento di 1.000.000 chiavi identiche un BST con Lista concatenata}
    \label{fig:bst-list-insetion-iterations}
  \end{minipage}%
\end{figure}



\begin{minipage}[t]{\linewidth}
\begin{multicols}{2}
\begin{minipage}{\linewidth}
    \centering
    \csvautotabular{./tests_output/bst_flag/insertion_summarised.cvs} % Percorso corretto per la prima tabella
    \captionof{table}{Inserimento in un BST con Flag Booleano}
    \label{tab:bst-flag-insertion-summarised}
\end{minipage}

\columnbreak

\begin{minipage}{\linewidth}
    \centering
    \csvautotabular{./tests_output/bst_list/insertion_summarised.cvs} % Percorso corretto per la seconda tabella
    \captionof{table}{Inserimento in un BST con Lista Concatenata}
    \label{tab:bst-list-insertion-summarised}
\end{minipage}

\end{multicols}

\end{minipage}

\vspace{10px}

Vediamo infine ciò che è veramente significativo: la visualizzazione del confronto diretto tra i 3 approcci.
Risulta subito evidente come entrambi gli approcci della lista concatenata e del flag booleano, nonostante magari la necessità di una iniziale progettazione e implementazione più specifica, portano enormi benefici. Entrambi i grafici di  {\cref{fig:comparison_insertion}} e {\cref{fig:comparison_insertion_zommed}} sono stati realizzati sulla base degli stessi dati già mostrati; il secondo è però più zoomato sull'asse delle y  così che si possano apprezzare anche le misurazioni di \textit{BST FLAG} e \textit{BST LIST}, prticamente impercettibile nella figura {\cref{fig:comparison_insertion}} dominata dal grafico del primo approccio.

\begin{figure}[htbp]
 \begin{minipage}{0.5\textwidth}
    \centering
    \includegraphics[width=\linewidth]{./tests_output/comparison_insertion.png}
    \caption{Confronto tra le prestazioni di inserimento dei 3 tipi di BST}
    \label{fig:comparison_insertion}
  \end{minipage}
      \hspace{0.05\textwidth}
  \begin{minipage}{0.5\textwidth}
    \centering
    \includegraphics[width=\linewidth]{./tests_output/comparison_insertion_zommed.png}
    \caption{Zoom del confronto tra le prestazioni di inserimento dei 3 tipi di BST}
    \label{fig:comparison_insertion_zommed}
  \end{minipage}%
\end{figure}



\newpage

% PC 
\section*{Nota sui test}
\addcontentsline{toc}{section}{Nota sui test}

Si tenga presente svolgere i test discussi è necessario alzare il limite massimo di ricorsione di default di Python. Questo è necessario per prevenire che l'interprete blocchi l'esecuzione di un elevato numero di chiamate ricorsive, però necessarie in questa tipologia di test.
Per fare ciò basta impostare un nuovo limite nel seguente modo:
\begin{lstlisting}[language=Python]
sys.setrecursionlimit(500000000)
\end{lstlisting}


\vspace{20pt}


Si tenga inoltre presente che tutti i test presenti in tale relazione sono stati eseguiti su un calcolatore con le seguenti specifiche:

\begin{multicols}{2}
    \textbf{Hardware:}
    \begin{itemize}
        \item \textbf{Modello:} MacBook Pro 2022
        \item \textbf{CPU:} Apple Silicon M2 (8 core)
        \item \textbf{RAM:} 8 GB LPDDR5 (Micron)
    \end{itemize}
    
    \columnbreak
    
    \textbf{Software:}
    \begin{itemize}
        \item \textbf{Versione macOS:} 14.0
        \item \textbf{Versione Python:} 3.11.4
        \item \textbf{Versione Pip3:} 23.3.2
    \end{itemize}
\end{multicols}

\vspace{20pt}

% BIBLIOGRAFIA 
\printbibliography[heading=bibintoc, title={Bibliografia}]  



\end{document}
